"""
처음부터 오른쪽까지 쭉 순회 => 만약 현재 값의 전 값이 현재 값보다 작다면,
현재 값의 전 값들 중 현재 값보다 작은 값들은 전부 제거, 제일 작은 값부터 제거
(인덱스를 넘어가는 경우를 방지하기 위해 인덱스 1부터 시작하여 현재 값과 전 값을 비교)
(number 길이가 2인 경우 존재.....)
(인덱스를 0부터 len(number)-1 까지 설정 / 현재 값과 다음 값 비교)
k개까지만 제거하는 로직 필요
제거하는 로직 짜는게 어려움... remove는 값 없으면 valueerror 발생
python식 for문 돌리면서 따로 변수 하나 지정해서 전 값 저장하는 식으로 가고,
number 직접 수정하며 가기

인덱스 i = 0부터 쭉 올라가며 max값을 갱신하고, [:i+1] 중 max보다 작은 값의 개수가 k가 이상이 될 때 [:i+1] 의 min값을 k번 지워준다! 그 배열을 [i+1:] 와 붙이기!
개선
python식 for문을 돌리며 max값과 현재값을 비교하며 max값을 갱신해 주고, 현재값을 subList에 append 해준 뒤 subList에서 max값보다 작은 값의 개수가 k개 이상이 되었을 때 subList의 가장 작은 값부터 k번 지워준다! 그 뒤 subList + 

1111111 같은 경우는 ..?

<최종본>
1. 왼쪽부터 오른쪽 끝까지 쭉 진행하면서, 현재 값과 다음 값을 비교해본다.
2. 현재값 >= 다음값 이라면 그냥 진행하고, 현재값 < 다음값 이라면 멈춘다.
3. 왼쪽끝부터 현재값까지 수 중에 다음값보다 작은 수를 지우되, 그 중 제일 작은 수부터 지운다.
(여기서 k값을 소모시키며 지운다.)
4. k = 0이 된다면 멈춘 뒤 결과를 반환하고, 끝까지 이동해도 k가 남아있다면 맨 왼쪽값부터
k개만큼 지운뒤 결과를 반환한다.
"""
def solution(number, k) :
    stack = []
    for num in number :
        while k > 0 and stack and stack[-1] < num :
            stack.pop()
            k -= 1
        stack.append(num)
        
    if k > 0 :
        stack = stack[:-k]
    
    return "".join(stack)